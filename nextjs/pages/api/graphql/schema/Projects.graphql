# Comments in GraphQL strings (such as this one) start with the hash (#) symbol.

#scalar ObjectID
scalar Date
scalar URL

#enum level_of_expertise {
#  BEGINNER
#  INTERMEDIATE
#  ADVANCED
#}

enum size_of_project {
    SMALL
    MEDIUM
    LARGE
}
enum reaction_type{
    LOVE,
    DISLIKE
}
#type Meta_data{
#    freelancer_id:ObjectID
#    reaction:Reaction_Types_Enum
#}
type reactions {
    freelancer_id:ObjectID!
    reaction_type:reaction_type!
    #    love: Int! # the count could be get from the reaction object
    #    dislike: Int!
    #    meta_data:[Meta_data!]
}

input ProjectScopeInput {
    estimated_duration_in_days: Int!
    @constraint(exclusiveMin: 0, exclusiveMax: 90)
    level_of_expertise: level_of_expertise!
    size_of_project: size_of_project!
}

type ProjectScopeOutput {
    estimated_duration_in_days: Int!
    @constraint(exclusiveMin: 0, exclusiveMax: 90)
    level_of_expertise: level_of_expertise!
    size_of_project: size_of_project!
}

enum ProjectCategoriesEnum {
    WEB_DEVELOPMENT
    MOBILE_DEVELOPMENT
    DESIGN
    DATA_SCIENCE
    MARKETING
    WRITING
    OTHER
}

type ProjectStats{
    status_count: Int! # the count of proposals that are in progress
    status_type: proposal_status# the count of proposals that are approved
}
type Project {
    client_id: ObjectID
    _id: ObjectID
    title: String!
    description: String!
    price: Float!
    skills: [String!]!
    reactions: [reactions]!
    created_at: Date!
    projectScope: ProjectScopeOutput
    attachmentsURL: [Attachment]
    proposals: [Proposal] # proposals for this project
    category: ProjectCategoriesEnum!
    stats: [ProjectStats]
}

# The "Query" type is special: it lists all of the available queries that


type queryResult {
    _id: ObjectID!
    acknowledgement: Boolean!
}
# filter options
input filterOptionsInput {
    priceMin: Float
    priceMax: Float
    category: ProjectCategoriesEnum
    skills: [String!]
}

